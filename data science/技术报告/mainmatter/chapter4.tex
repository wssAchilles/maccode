% !TEX root = ../main.tex
\chapter{建模方法与算法设计}

\section{模型选择与理论简述}

\subsection{负载预测：随机森林回归}
本项目选择随机森林（Random Forest）作为负载预测模型，基于以下考量：
\begin{itemize}
    \item \textbf{非线性建模}：EDA表明温度与负载存在非线性关系，随机森林通过决策树的层级分裂天然捕捉此特性；
    \item \textbf{对异常值鲁棒}：基于Bagging集成，单个异常样本影响有限；
    \item \textbf{无需特征缩放}：Hour（0--23）与Temperature（10--40）等不同量纲特征可直接输入。
\end{itemize}

\subsection{储能优化：混合整数规划 (MIP)}
储能调度涉及“充”与“放”的状态互斥逻辑（不能同时充电和放电），这引入了二进制变量$z(t) \in \{0, 1\}$。因此，该问题属于混合整数规划范畴。本项目选用 Gurobi 求解器，利用其高效的分支定界算法保证获得全局最优解。

\section{特征工程与变量选择}

特征工程将原始数据转化为模型可学习的结构化特征。

\subsection{时间特征提取}
\texttt{add\_time\_features()} 方法从时间戳中提取两类周期性特征：
\begin{itemize}
    \item \textbf{Hour} (0--23)：捕捉日内周期性（如工作时段与休息时段的负载差异）；
    \item \textbf{DayOfWeek} (0--6)：捕捉周内周期性（工作日 vs 周末）。
\end{itemize}

\subsection{分时电价特征构建}
电价是储能优化的核心输入。\texttt{add\_price\_feature()} 方法基于加州分时电价（TOU）规则构建特征：
\begin{lstlisting}[language=Python]
def get_price(hour: int) -> float:
    if 0 <= hour < 8: return 0.3   # 谷时
    elif 8 <= hour < 18: return 0.6 # 平时
    elif 18 <= hour < 22: return 1.0 # 峰时
    else: return 0.3
\end{lstlisting}
该特征直接引导优化算法实现“低买高卖”。

\subsection{算法实现：随机森林回归}

本项目基于 Python 的 \texttt{scikit-learn} 库中的 \texttt{RandomForestRegressor} 类实现负载预测模型。核心实现逻辑如下：

\begin{itemize}
    \item \textbf{模型初始化}：实例化模型时，设置树的数量 \texttt{n\_estimators=100}，并固定随机种子 \texttt{random\_state=42} 以确保结果的可复现性。为了提高训练效率，利用 \texttt{n\_jobs=-1} 参数调用所有可用的 CPU 核心进行并行计算。
    \item \textbf{数据输入}：输入特征矩阵 $X$ 包含 \texttt{Hour}, \texttt{DayOfWeek}, \texttt{Temperature}, \texttt{Price} 四个维度，目标变量 $y$ 为 \texttt{Site\_Load}。
    \item \textbf{数据集划分}：使用 \texttt{train\_test\_split} 函数按 8:2 的比例随机划分训练集和测试集 (Train/Test Ratio = 0.8/0.2)。
\end{itemize}

\subsubsection{模型可解释性 (SHAP)}
为了解决随机森林作为“黑盒”模型缺乏解释性的问题，我们集成了 \texttt{SHAP} (SHapley Additive exPlanations) 框架。具体地，使用 \texttt{shap.TreeExplainer} 对模型进行解析，计算特征的 Shapley 值。这使得系统能够通过 \texttt{explain\_prediction} 接口，为每一次单点预测提供“特征贡献度”分析（例如：“当前小时为 14:00，这使得负载预测值增加了 15kW”），从而增强用户对 AI 决策的信任度。

\subsubsection{在线评估与模型监控}
为了确保模型在生产环境中的持续有效性，系统实现了一个在线评估机制 \texttt{evaluate\_recent\_performance}。该机制逻辑如下：
\begin{enumerate}
    \item \textbf{滚动回测}：每次触发时，自动从持久化存储中拉取最近 24 小时 ($T=24$) 的真实负载数据 $y_{true}$。
    \item \textbf{实时指标计算}：利用当前模型对该时间段的历史特征进行预测得到 $y_{pred}$，并计算平均绝对百分比误差 (MAPE) 和判定系数 ($R^2$)。
          \begin{equation}
              \text{MAPE} = \frac{100\%}{n} \sum_{t=1}^{n} \left| \frac{y_{true}[t] - y_{pred}[t]}{y_{true}[t]} \right|
          \end{equation}
    \item \textbf{反馈回路}：评估结果实时反馈至前端仪表盘，若 MAPE 显著升高，系统将提示管理员考虑重新训练模型。
\end{enumerate}

\section{优化算法设计}

\subsection{混合整数规划模型 (MIP)}

基于 \texttt{gurobipy} 求解器，我们在 \texttt{optimization\_service.py} 中构建了如下数学模型。为了适配云原生架构（如 Google App Engine），我们特别集成了 \textbf{Gurobi WLS (Web License Service)}。系统启动时会自动检查环境变量 \texttt{GRB\_WLSACCESSID} 和 \texttt{GRB\_WLSSECRET}，动态获取许可证，从而摆脱了物理机器指纹绑定的限制，实现了容器化部署的弹性伸缩。

\subsubsection{决策变量}
对于未来 $T=24$ 个时段，定义如下决策变量：
\begin{enumerate}
    \item $P_{\text{charge}}[t] \in [0, P_{\max}]$：$t$ 时刻的充电功率 (Continuous)，代码变量名为 \texttt{P\_charge}。
    \item $P_{\text{discharge}}[t] \in [0, P_{\max}]$：$t$ 时刻的放电功率 (Continuous)，代码变量名为 \texttt{P\_discharge}。
    \item $E_{\text{stored}}[t] \in [0, E_{\text{cap}}]$：$t$ 时刻的电池储能量 (Continuous)，代码变量名为 \texttt{E\_stored}。
    \item $Is_{\text{charge}}[t] \in \{0, 1\}$：充电状态指示变量 (Binary)，代码变量名为 \texttt{Is\_charge}。
    \item $Is_{\text{discharge}}[t] \in \{0, 1\}$：放电状态指示变量 (Binary)，代码变量名为 \texttt{Is\_discharge}。
\end{enumerate}

\subsubsection{约束条件}
\begin{enumerate}
    \item \textbf{状态互斥约束}：确保电池不能同时处于充电和放电状态。
          \begin{equation}
              Is_{\text{charge}}[t] + Is_{\text{discharge}}[t] \le 1, \quad \forall t \in T
          \end{equation}

    \item \textbf{功率限制约束}：充放电功率受物理设备限制且受状态变量控制。
          \begin{align}
              P_{\text{charge}}[t]    & \le P_{\max} \cdot Is_{\text{charge}}[t]    \\
              P_{\text{discharge}}[t] & \le P_{\max} \cdot Is_{\text{discharge}}[t]
          \end{align}

    \item \textbf{能量守恒约束}：电池电量的动态变化遵循物理守恒定律。值得注意的是，代码实现中充放电效率 $\eta=0.95$ 作用于能量转换过程：充电时从电网吸收能量乘以效率转化为化学能，放电时释放化学能除以效率转化为电能（为了提供同样的输出功率，电池内部需消耗更多能量）。
          \begin{equation}
              E_{\text{stored}}[t] = E_{\text{stored}}[t-1] + P_{\text{charge}}[t] \cdot \eta - \frac{P_{\text{discharge}}[t]}{\eta}
          \end{equation}
          特例：当 $t=0$ 时，$E_{\text{stored}}[0]$ 基于初始电量 $E_{\text{init}}$ 计算。
\end{enumerate}

\subsubsection{目标函数}
优化目标是最小化全天的净购电成本：
\begin{equation}
    \min \sum_{t=0}^{23} \left( (\text{Load}[t] + P_{\text{charge}}[t] - P_{\text{discharge}}[t]) \cdot \text{Price}[t] \right)
\end{equation}
该目标函数在 Gurobi 中通过 \texttt{model.setObjective(total\_cost, GRB.MINIMIZE)} 设定，求解器在毫秒级内搜索最优的充放电策略序列。

\subsection{算法整体执行流程}

为了实现自动化的能源调度，系统将负载预测与储能优化串联，形成“预测-优化”闭环。整体算法流程如下所示：

\begin{algorithm}[H]
    \caption{“预测-优化”闭环调度算法}
    \label{alg:optimization_loop}
    \begin{algorithmic}[1]
        \Require 当前时刻 $t_{\text{now}}$, 天气预报 $W_{24h}$, 历史负载数据 $D_{\text{hist}}$
        \Ensure 未来 24 小时充放电调度计划 $S_{\text{opt}}$

        \State \textbf{Step 1: 负载预测 (Predict)}
        \State $M \leftarrow \text{LoadModel}(\text{RandomForest})$ \Comment{加载预训练模型}
        \For{$h \leftarrow 0$ to $23$}
        \State $T_{\text{temp}} \leftarrow W_{24h}[h].\text{temperature}$
        \State $P_{\text{price}} \leftarrow \text{GetPrice}(t_{\text{now}} + h)$ \Comment{查询分时电价表}
        \State $L_{\text{pred}}[h] \leftarrow M.\text{predict}(\text{Attributes}(h, T_{\text{temp}}, P_{\text{price}}))$
        \EndFor

        \State \textbf{Step 2: 储能优化 (Optimize)}
        \State $E_{\text{init}} \leftarrow \text{GetCurrentSOC}()$ \Comment{读取当前电池电量}
        \State $\text{Model}_{\text{MIP}} \leftarrow \text{GurobiEnv}.\text{createModel}()$
        \State $\text{Model}_{\text{MIP}}.\text{addVariables}(P_{\text{charge}}, P_{\text{discharge}}, E_{\text{stored}}, \dots)$
        \State $\text{Model}_{\text{MIP}}.\text{addConstraints}(\text{Mutex}, \text{PowerLimit}, \text{EnergyBalance})$
        \State $\text{Model}_{\text{MIP}}.\text{setObjective}(\min \text{TotalCost})$
        \State $\text{Model}_{\text{MIP}}.\text{optimize}()$

        \State \textbf{Step 3: 结果解析与执行}
        \If{$\text{Model}_{\text{MIP}}.\text{status} == \text{OPTIMAL}$}
        \State $S_{\text{opt}} \leftarrow \text{ExtractSolution}(\text{Model}_{\text{MIP}})$
        \State \Return $S_{\text{opt}}$
        \Else
        \State \textbf{Exception}: 优化失败，回退到默认策略
        \EndIf
    \end{algorithmic}
\end{algorithm}
