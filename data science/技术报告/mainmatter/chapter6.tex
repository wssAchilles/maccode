% !TEX root = ../main.tex
\chapter{工程实现与项目管理}

\section{项目结构与代码组织}

\subsection{系统总体架构}

本系统采用经典的 B/S (Browser/Server) 架构模式，通过分层设计确保系统的可扩展性。

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[
            node distance=0.6cm,
            box/.style={rectangle, draw, rounded corners=3pt, minimum height=0.9cm, text centered, font=\small},
            arrow/.style={->, >=stealth}
        ]
        % 前端层
        \node[box, fill=blue!10, minimum width=12cm] (frontend) {前端层 (Flutter App / Web Dashboard)};

        % 后端层
        \node[box, fill=green!10, minimum width=12cm, below=of frontend, yshift=-1cm] (backend) {后端层 (Flask REST API on Google App Engine)};

        % 数据层
        \node[box, fill=orange!10, minimum width=12cm, below=of backend, yshift=-1cm] (data) {数据层 (Google Firebase)};

        % 连接
        \draw[arrow] (frontend) -- node[right] {HTTPS / JSON} (backend);
        \draw[arrow] (backend) -- node[right] {SDK} (data);
    \end{tikzpicture}
    \caption{储能智能管理系统总体架构图}
    \label{fig:system_arch}
\end{figure}

如图~\ref{fig:system_arch}所示，系统分为三层：
\begin{itemize}
    \item \textbf{前端层}：基于 Flutter 开发，支持多端运行，负责数据展示与用户交互；
    \item \textbf{后端层}：基于 Flask 开发，托管于 Google App Engine，负责业务逻辑、算法调用和 API 响应；
    \item \textbf{数据层}：基于 Firebase，提供无服务器（Serverless）的数据库（Firestore）和文件存储（Storage）能力。
\end{itemize}

\subsection{技术栈选型}

\begin{table}[htbp]
    \centering
    \caption{系统技术栈选型}
    \label{tab:tech_stack}
    \begin{tabular}{llp{7cm}}
        \toprule
        \textbf{层次} & \textbf{技术}            & \textbf{说明}                                                 \\
        \midrule
        前端          & Flutter (SDK 3.10.0)   & 跨平台移动应用开发，集成 \texttt{fl\_chart} 可视化库与 \texttt{http} 客户端     \\
        后端          & Flask (Python 3.11)    & RESTful API 服务，使用 Gunicorn 作为 WSGI 服务器                      \\
        算法          & Scikit-learn, Gurobipy & 用于随机森林预测与 MIP 优化求解（配置 WLS 许可证）                              \\
        数据库         & Firebase               & 集成 Authentication (身份认证), Firestore (NoSQL), Storage (文件存储) \\
        部署          & Google App Engine      & Serverless F4 实例，支持自动扩缩容                                    \\
        \bottomrule
    \end{tabular}
\end{table}

\section{自动化流水线与复现性}

\subsection{RESTful API 接口设计}

后端遵循 RESTful 风格设计 API，封装于 \texttt{api\_service.dart} 中，核心接口如下：

\begin{table}[htbp]
    \centering
    \caption{核心 RESTful API 接口详解}
    \label{tab:api_endpoints}
    \begin{tabular}{lp{4cm}p{4cm}p{3cm}}
        \toprule
        \textbf{端点 (Endpoint)}         & \textbf{功能描述} & \textbf{关键请求参数}                                               & \textbf{超时设置} \\
        \midrule
        \texttt{/api/ml/predict}       & 负载预测          & \texttt{start\_time}, \texttt{temp\_forecast}                 & 60s           \\
        \texttt{/api/ml/train}         & 模型重训练         & \texttt{n\_estimators}, \texttt{data\_path}                   & 300s          \\
        \texttt{/api/optimization/run} & 储能调度优化        & \texttt{initial\_soc}, \texttt{battery\_cap}, \texttt{target} & 60s           \\
        \texttt{/api/analysis/analyze} & CSV 大文件分析     & \texttt{storage\_path}, \texttt{filename}                     & 180s          \\
        \texttt{/api/history}          & 历史记录查询        & \texttt{limit}, \texttt{start\_date}                          & 10s           \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{安全与异常处理机制}
系统在 \texttt{api\_service.dart} 中实现了健壮的异常捕获与重试机制，针对不同 HTTP 状态码定义了标准处理流：
\begin{itemize}
    \item \textbf{401 Unauthorized}：当 Firebase ID Token 过期或无效时触发。前端拦截器会捕获该错误，并自动引导用户跳转至登录页重新认证（\texttt{FirebaseAuth.instance.currentUser?.getIdToken(true)}）。
    \item \textbf{500 Internal Server Error}：主要针对 Gurobi 求解器可能出现的许可证异常（如 License Server 连接超时）。系统会解析错误响应体中的 \texttt{message} 字段，若包含 "License" 关键字，则向用户展示具体的许可证排查指引，而非通用的“服务器错误”。
    \item \textbf{请求超时 (Timeout)}：针对 \texttt{/api/analysis} 等长耗时接口，前端设置了 3 分钟的硬性超时阈值，若后端未在规定时间内返回分析结果，则自动中止请求并提示用户缩小文件体积。
\end{itemize}

\subsection{数据持久化机制}

系统利用 Firebase 实现数据的云端持久化：
\begin{itemize}
    \item \textbf{Cloud Storage}：存储原始能耗 CSV 文件和序列化的 \texttt{.joblib} 模型文件；
    \item \textbf{Cloud Firestore}：存储结构化的用户配置、优化结果日志和模型元数据（Model Metadata）；
    \item \textbf{Authentication}：利用 Firebase Auth 实现安全的用户身份鉴权，前端每次请求均附带 Bearer Token。
\end{itemize}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/firebase1.png}
    \caption{Firebase Storage 云端存储管理}
    \label{fig:firebase_storage}
\end{figure}

\section{容器化与部署}

\subsection{Docker 容器化}

为确保开发与生产环境的一致性，本项目采用 Docker 进行容器化封装。`Dockerfile` 基于 Python 3.11 构建：

\begin{lstlisting}
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
# 安装 Gurobi 依赖库
RUN pip install -r requirements.txt
COPY . .
# 使用 Gunicorn 启动 Flask 应用，设置 5 分钟超时
CMD ["gunicorn", "-b", ":$PORT", "--timeout", "300", "--workers", "1", "main:app"]
\end{lstlisting}

\subsection{Google App Engine 部署}

系统部署于 Google Cloud Platform 的 App Engine (Standard Environment)。我们精心调优了 \texttt{app.yaml} 配置以在性能与成本之间取得平衡：

\begin{lstlisting}
runtime: python311
instance_class: F4        # 内存优化型实例 (1024MB RAM, 2.4GHz CPU)
automatic_scaling:
  min_instances: 0        # 闲置时自动从容至 0，实现"按需付费"
  max_instances: 1        # 限制并发实例数，防止恶意流量导致费用失控
env_variables:
  GRB_LICENSEID: '...'    # 配置 Gurobi WLS 许可证
  GCP_PROJECT_ID: 'data-science-44398'
\end{lstlisting}

\begin{itemize}
    \item \textbf{实例选型 (\texttt{F4})}：Scikit-learn 的随机森林模型加载和 Gurobi 的矩阵运算均属于内存密集型任务。F1/F2 实例常因内存溢出 (OOM) 导致服务重启，因此选用 F4 (1024MB 内存) 确保算法运行稳定性。
    \item \textbf{自动扩缩容 (\texttt{Scaling})}：配置 \texttt{min\_instances: 0} 使得服务在夜间无人使用时完全休眠，将云资源成本降至最低。
\end{itemize}
